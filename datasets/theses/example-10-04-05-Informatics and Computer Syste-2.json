{"paragraph_source_docs": [2, 2, 1, 0, 0, 1, 2, 2, 2, 1], "paragraphs": ["ա․                                                            բ․ Նկար 2.12. ա) վերահսկվող տարածքը, բ) օբյեկտի առկայությունը վերահսկվող տարածքում: ", "Վերահսկվող  տարածքում  կարող  է  ներթափանցել  ցանկացած  օբյեկտ,  և տարածքի  վերահսկողության  պատասխանատու  անձը  կամ  խումբը  նախօրոք  չի կարող  կանխատեսել,  թե  ինչպիսի  օբյեկտ  կներթափանցի  տարածք:  Նկար  2.12ա-ում պատկերված  երկաթուղային  կայարանում  օբյեկտի  հայտնաբերումը  խիստ  կարևոր  է: ", "Մասնավորապես, երկչափ և եռաչափ ցանցերի դեպքում կունենանք Նկար 41 և 42- ում բերված պատկերները, որտեղ միևնույն գույնով նշված գագաթներն անկախ են: ", "Հեշ  ֆունկցիան    կարող  է  դասակարգվել  բանալիով  կամ  առանց  բանալու հեշավորման  ֆունկցիաների:  Բանալիով  հեշ  ֆունկցիան  ունի  լրացուցիչ  մուտք,  որն ընդունված  է  նշանակել  k  պարամետրով:  Արդյունքում  առանց  k-ի  իմացության  hk(M) հեշավորման աշխատանքն անհնար է իրականացնել։ Ինչպես նաև հաղորդագրության և ելքային  հեշի  իմացության  պարագայում  բանալու  որոնումը  հաշվողական  առումով նույնպես անհնար է: ", "Հեշավորման  ֆունկցիաների  մեծամասնությունը,  ինչպիսիք  են՝  MD4,  MD5,  MD6, SHA1  և  SHA2  հեշ  ֆունկցիաները,  օգտագործում  են  Merkle–Damgård  սխեման  և  բիթային գործողություններ  կատարում  մուտքային  հաղորդագրության  վրա՝      վերջնական  հեշ արժեքը ստանալու նպատակով [47, 49, 50]։ ", "Անկախ  հանգույցները  կարող  են  միաժամանակ  փլուզվել`  բերվել  կայուն վիճակի, առանց «խանգարելու» միմյանց: ", "ա.                               բ. Նկար 2.14․ ա) վերահսկվող տարածքը, բ) ծառը տատանման պահին: ", "ծառի առկայության դեպքում: ", "Նկար  2.14բ-ում  պատկերված  է  ծառը  քամու  ազդեցության  տակ  տատանման պահը:  Ծառի  տատանման  արդյունքում  պատկերում  առաջանում  է  պիքսելների փոփոխոթւյուն:  Սկզբնական  պատկերը,  որտեղ  ծառը  գտնվում  էր  անշարժ  վիճակում, համեմատենք ընթացիկ պատկերի հետ XOR բիթային համեմատության սկզբունքով: ", "Այս ծրագրաապարատային զուգահեռ հաշվարկման ճարտարապետությունը թույլ է տալիս բարձրացնել հաշվողական արտադրողականությունը:  Այսինքն  CUDA-ի  միջոցով  վերը  նշված  ալգորիթմը աշխատեցնում  ենք  վիդեոքարտի(GPU)  վրա:  Հիշեցնեմ  որ  GPU-ն  ունի  բազմաթիվ միկրոպրոցեսներ,  որոնց  քանակությունը  զգալի  շատ  է  CPU-ի  պրոցեսորների քանակից:  Օգտագործողը  կարող  է  կանչել  1-512  հոսքերից  կազմված  բլոկը:  Իսկ բլոկերն  էլ  իրենց  հերթին  կազմում  են  միկրոպրոցեսների  ամբողջ  ցանցը:  Ամեն հոսք  բլոկի  մեջ  ունի  յուրահատուկ  ID:  Բլոկները  նույնպես  ընդհանուր  ցանցի  մեջ ունեն  յուրահատուկ  ID:  Ինչպես  նաև  կան  տարբեր  հիշողություններ,  որոնց  հետ հոսքերը  տարբեր  արագությամբ  են  աշխատում:  Նկար  43-ից  GPU-ի  աշխատանքը ավելի  պարզ  է  դառնում:  CUDA  տեխնոլոգիա  օգտագործող  ծրագրային համակարգի  արագությունը  կախված  է  ինչպես  հիշողության` այնպես  էլ  բլոկերի  և հոսքերի  հարաբերակցության  ճիշտ  ընտրությունից:  Օրինակ  միևնույն  ծրագրի աշխատանքը 2 բլոկ' յուրաքանչյուրում 20-ական հոսք և 1 բլոկ 40-ական հոսքերով կարող է ժամանակային 4 անգամ տարբերություն տալ: "], "source_docs_file": "Informatics and Computer Systems.json"}