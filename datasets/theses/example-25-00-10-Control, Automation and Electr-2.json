{"paragraph_source_docs": [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], "paragraphs": ["է հաջորդ մոդուլի կարդալը, եթե այն առկա է։ ", "- 71 - Այսպիսով, ԱՀԳ-ում ստացվում է ՝   “vector<Wire> g_wires” ` բոլոր շղթաների զանգվածը (աղ․  3․ 1),   “vector<Cell > g_cells” ` բոլոր տարրերի զանգվածը (աղ․  3․ 2),   “set<int> g_input” ՝ input փականների id-երի set (նկ․  3.3),   “set<int> g_output” ՝ output փականների id-երի set (նկ․  3.4),   “map<string, int> g_gate_name_to_id” ` map ` տարրի անունից դեպի իր id (նկ․  3.5)։ ", "Թվարկված կոնտեյներները C++ ստանդարտ գրադարանից են[80]։ ", "vector-ը զանգված է, set-ը և map-ը բինար որոնման բալանսավորված ծառեր են։ ", "ԱՀԳ-ի  տրամաբանական  տարրը  կապող  շղթաների  բազմությունը  ներկայացնում  է զանգված աղ․  3․ 1-ը։ ", "ԱՀԳ-ի շղթաների «Wire»  զանգվածի կառուցվածքը Աղյուսակ 3.1 Զանգվածի տարրի համարը Շղթայի անունը Շղթայի id Շղթայի սկիզբ Շղթայի վերջ պահուստը G1 G16 G17 G2 G3 G4 G5 G8 G9 G12 G15 ժամանակի Զանգվածի ամեն տարրում պահվող տվյալները հետևյալն են՝ - 72 - բալանսավորված  ծառ։  Ծառի  ամեն  տարրը  պահում  է  տրամաբանական  տարրի բալանսավորված ծառ։ Ծառի ամեն տարրը պահում է տրամաբանական տարրի(Cell- տվյալներ  են,  վերցվում  են  սխեմայի  ստատիկ  ժամանակային  վերլուծության (Cell-ի) id-ն, ի) id-ն, արդյունքից։ ", "Օրինակ՝  8  id  ոնեցող  շղթան(G9)  սկսվում  է  1  id  ունեցող  տրամաբանական  տարրից, որը  NAND2_1-ն  է,  և  ավարտվում  է  2  և  3  id  ունեցող  տրամաբանական  տարրերին միանալով, որոնք էլ  NAND2_2 և NAND2_3 տարրերն են։ Ավելի մանրամասն տարրի id- ն ներկայացված է աղ․  3.2 տարրի զանգվածի նկարագրությունում։ ", "ԱՀԳ-ի տարրերի «Cell»  զանգվածի կառուցվածքը Աղյուսակ 3.2 Զանգվածի տարրի համարը Տարրի id Տարրի անունը շղթայի id Տարրի ելքային շղթայի id Տարրի ռանգը Տարրի մուտքային NAND2_0  NAND2_1  NAND2_2  NAND2_3 NAND2_4 NAND2_5 Դիտարկենք տարրերի զանգվածի 0-րդ տարրը՝ - 73 - տարրերի տվյալները, կտեսնենք, որ դրանք G1 և G3 շղթաներն են, կտեսնենք, որ այն ներկայացնում է՝ G8, չէ․ այն  կարժեքավորվի  ռանգավորման ալգորիթմի աշխատանքից հետո։ ", "Այսպիսով,  ստացանք  NAND2_0(G8,G1,G3),  ինչն  էլ  համապատասխանում  է թեստային verilog ֆայլի 9-րդ տողին(նկ․ 3.2)։ ", "Ալգորիթմի  2-րդ  և  3-րդ  կետերի  աշխատանքի  արդյունքում՝  վերոնշյալ  տեստային վերլոգ ֆայլի 2-րդ և 3-րդ տողերում գրված ինֆորմացիան պահվում է հետևյալ կերպ։ ", "Մուտքային  շղթաներ։  Ալգորիթմի  աշխատանքի  արդյունքում  պահվում  է  բինար որոնման բալանսավորված ծառ [76, 80]։ Ծառի ամեն տարր իր մեջ պահում է մուտքային շղթայի  id։  Verilog  ֆայլի  (նկ․ 3․ 2)  4-րդ  տողում  գրված  է՝  G1,G2,G3,G4,G5;  այսինքն՝ կպահվի նրանց id-երը, որոնք 0, 3, 4, 5, 6 -ն են (աղ.3․ 1)։ ", "Այսպիսով, ստացվեց նկ.3.3-ում նեկայացված պատկերը։ ", "Նկ․  3․3․   Մուտքային  շղթաների  id-երը  բինար  որոնման բալանսավորված ծառում Ելքային շղթաներ ։ Աշխատում է նույն ձևով, ինչպես մուտքայինի դեպքում, սակայն այստեղ պահվում են 5-րդ տողում գրված շղթաների G16,G17-ի  id-երը (նկ․ 3․ 4)։ ", "- 74 - Նկ․ 3․4․  Ելքային շղթաների id-երը բինար որոնման բալանսավորված ծառում Մուտքային  և  ելքային  շղթաների  այսպիսի  ծառերի[76]  տեսքով  պահվող ինֆորմացիան  թույլ  է  տալիս  հեշտությամբ  O(log  n)  (լոգարիթմական)  ժամանակում կատարել  որոնում՝  մուտքային  կամ  ելքային  շղթաների  բազմությունում,  ինչն  էլ,  իր հերթին,  նպաստում է  ԱՀԳ-ի  վրա  հետագայում  կիրառելի  ալգորիթմների արագագործությանը։ ", "Նման  գրաֆով  աշխատանքի  համար  անհրաժեշտություն  է  առաջանում  շղթայի անունով  գտնել  շղթայի  id-ն։  Բացի  այն  բանից,  որ  ունենալով  ցանկացած  շղթայի  id-ն, կարելի  է  կողերի  զանգվածում  գտնել  նրա  անունը  (աղ․ 3․ 1),  նաև  կարելի  է  անել հակառակը,  ուենալով  անունը՝  գտնել id-ն  նկ․ 3.4  -ի  և  աղ  2-ի  միջոցով։  Այս հնարավորության համար անհրաժեշտ է ունենալ map անունից դեպի id․ map-ը բինար որոնման բալանսավորված ծառ է։ Նրա ամեն տարրը ներկայացնում է {key, value} զույգ։ ", "Որոնումը և բալանսավորումը կատարվում է key-ի միջոցով, որոնք ծառի մեջ չեն կարող կրկնվել,  իսկ  value  -  ն  ներկայացնում  է  ցանկացած  տվյալ։  Մեր  օրինակու`  key-ը (բանալի) շղթայի անունն  է  (օրինակ՝ G1  կամ G2  ․ ․ ․ ),  իսկ value-ն՝  համապատասխան կողի id-ն (աղ.3․ 1)։ ", "Վերոնշյալ verilog ֆայլի օրինակում կունենանք հետևյալ map-ը (նկ․ 3.5)։ ", "- 75 - {G8, 7} {G15, 11} {G3, 4} {G2, 3} {G1, 0} {G4, 5} {G12, 10} {G16, 1} {G5, 6} {G9, 9} {G17, 2} Նկ․  3.5․   ԱՀԳ-ի  շղթաների  բազմության  անունից  դեպի  իրենց  id կառուցված map Այսպիսով,  սխեմայի  ֆունկցիոնալ-տրամաբանական  առանձնահատկությունների հաշվառման, տվյալների մշակման և ԻՍ ֆիզիկական նախագծման համար նախագծվել է  տվյալների  պահման  այնպիսի  մոտեցում,  որը  հիմնված  է  բինար  որոնման բալանսավորված  ծառի[76],  տարրերի  և  շղթաների  զանգվածների  վրա[78,  79],  ինչն  էլ, իր  հերթին,  նշանակում  է  սխեմայի  մուտքային  փականային  մակարդակի  Verilog նկարագրության նախնական փոխակերպումը ազդանշանների հոսքի գրաֆի (ԱՀԳ-ի)։ ", "Սխեմայի տրամաբանական տարրերի ռանգավորումը կատարվում  է ԱՀԳ-ի՝ G(W,C) բազմամակարդակ գրաֆի  փոխակերպմամբ, որի համար հարկավոր է C բազմությունը բաժանել այնպիսի m մակարդակների ( կամ ռանգերի)՝ , որ ցանկացած -ից դեպի ուղղորդված շղթայի համար, որտեղ , տեղի ունենա (3.1) ` , եթե և ։                                           (3.1) Սխեմայի  տրամաբանական  բջիջների  ռանգավորումը  կատարվում է  այն ենթադրության  հիման  վրա,  որ  ցանկացած  տարրի  ռանգ  մեկով  ավելի  է,  քան  այդ տարրի մուտքերին միացված այլ տարրերից առավելագույնի ռանգը։ Որոշակի i տարրի Ri ռանգը որոշվում է հետևյալ կերպ՝ - 76 - (3.2) որտեղ -    ն  i-րդ  տարրի  մուտքային  շղթաների  բազմությունն  է, -ը՝  սխեմայի առաջնային  մուտքերի  բազմությունը, -ն    k-րդ  տարրի  ռանգը, –ն՝  i-րդ  տարրի մուտքերին միացված տարրերի բազմությունը, N -ը սխեմայի տարրերի քանակը։ ", "Տրամաբանական  սխեմայի  Verilog  նկարագրից  ազդանշանների  հոսքի  գրաֆի ստացման  և  սխեմայի  տարրերի  ռանգավորման  նպատակով  օգտագործված  է տվյալների  ներկայացման    և  հետագա  փնտրման  բինար  որոնման  բալանսավորված ծառի սկզբունքը: Սկզբնական վիճակում բոլոր տարրերն էլ ռանգ չունեն, և դրա համար նրանց բոլորին տրվում է 0 ռանգ։ Ռանգավորման ալգորթմը բաղկացած  է 4 հիմնական քայլերից․ գրված  շղթաները)  վերագրել  1-ին  ռանգ։  Այն  բոլոր  տարրերին,  որոնց  բոլոր  մուտքային շղթաները սխեմայի առաջնային մուտքային շղթաներ են, տրվում է 1-ին ռանգը։ ", "ռանգ,  ստանում  են  առավելագույն  ռանգ  ունեցող  շղթայի  ռանգը,  իսկ  նրանց  ելքային շղթային տրվում է  1-ով ավել ռանգ։ ", "սկզբնական վիճակում կլինի` Եթե  ci    տարրի  ռանգը  նշանակենք ,  իսկ  wi  շղթայի  ռանգը՝  r(wi),  ապա (3.3) որտեղ - -ը i -րդ տարրի մուտքային շղթաներից առավելագույն ռանգ ունեցողն է, իսկ –ը i -րդ տարրի ելքային շղթայի ռանգն է: ", "),  ապա  դա  նշանակում  է,  որ  գրաֆում  գոյություն  ունի  տարրերի  այնպիսի հաջորդականություն,  որը  կազմում  է  փակ  շրջան՝  ցիկլ։  Անհրաժեշտ  է  գտնել չռանգավորված տարրերի այդ ցիկլը: ", "- 77 - ։ ", "Այս  քայլում  պետք  է  սկսենք  կամայական  տարրից՝ ,  որը  չունի  ռանգ` Եթե  տարրը  ռանգ  չունի,  դա  նշանակում  է,  որ  նրա  գոնե  մեկ  մուտքային  շղթա՝ ռանգ չունի, այլապես 2-րդ քայլում , տարրը կռանգավորվեր։ Գրանցում ենք ,  -ն և շարունակում հետևյալ կերպ։ "], "source_docs_file": "Control, Automation and Electrical Engineering.json"}